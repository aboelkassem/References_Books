<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

  <title>timer_create(2) — Linux manual pages</title>
  <link rel="stylesheet" type="text/css" href="../stylesheet/manpages.css" />
  
  <link rel="home" href="../index.html" title="timer_create(2) — Linux manual pages" />
  <script type="text/javascript" src="../stylesheet/manpages.js" xml:space="preserve">
</script>
  <link rel="icon" href="../stylesheet/icon.gif" type="image/gif" />
</head>

<body onload="javascript:init()">
  <div class="navheader">
    <table width="100%">
      <tbody>
        <tr>
          <td style="width: 33%" rowspan="1" colspan="1"><a href="../index.html" shape="rect">Linux
          manual pages</a></td>

          <th rowspan="1" colspan="1"><a href="../index2.html" shape="rect">Section 2</a></th>

          <td style="width: 33%" rowspan="1" colspan="1"> </td>
        </tr>
      </tbody>
    </table>
    <hr />
  </div>

  <div class="refentry">
    <a id="timer-create.2" name="timer-create.2" shape="rect"> </a>

    <div class="titlepage"> </div>

    <div class="refnamediv">
      <h2>Name</h2>

      <p>timer_create — create a POSIX per-process timer</p>
    </div>

    <div class="refsynopsisdiv">
      <h2>Synopsis</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 #include &lt;signal.h&gt;
 #include &lt;time.h&gt;
</pre>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>timer_create</strong>(</code></td>

            <td rowspan="1" colspan="1">clockid_t <var class="pdparam">clockid</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">struct sigevent *<var class="pdparam">sevp</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">timer_t *<var class="pdparam">timerid</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
        <table border="0" summary="Note">
          <tr>
            <td rowspan="2" align="center" valign="top" width="25" colspan="1">
            <img alt="[Note]" src="../stylesheet/note.png" /></td>

            <th align="left" rowspan="1" colspan="1">Note</th>
          </tr>

          <tr>
            <td align="left" valign="top" rowspan="1" colspan="1">
              <div class="featuretests">
                <table style="border-collapse: collapse;">
                  <colgroup span="1">
                    <col span="1" />
                  </colgroup>

                  <thead>
                    <tr>
                      <th style="" rowspan="1" colspan="1">Feature Test Macro Requirements
                      for glibc (see <a class="link" href="../htmlman7/feature_test_macros.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">feature_test_macros</span>(7)</span></a>):</th>
                    </tr>
                  </thead>

                  <tbody>
                    <tr>
                      <td style="" rowspan="1" colspan="1"><code class="function">timer_create</code>():</td>
                    </tr>

                    <tr>
                      <td class="featuretestdef" style="" rowspan="1" colspan="1">
                      <code class="constant">_POSIX_C_SOURCE</code>
                      &gt;= 199309L</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </td>
          </tr>
        </table>
      </div>

      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
        <table border="0" summary="Note">
          <tr>
            <td rowspan="2" align="center" valign="top" width="25" colspan="1">
            <img alt="[Note]" src="../stylesheet/note.png" /></td>

            <th align="left" rowspan="1" colspan="1">Note</th>
          </tr>

          <tr>
            <td align="left" valign="top" rowspan="1" colspan="1">
              <p>Link with <code class="option">−lrt</code>.</p>
            </td>
          </tr>
        </table>
      </div>
    </div>

    <div class="refsect1">
      <a id="timer-create-2_sect1" name="timer-create-2_sect1" shape="rect"> </a>

      <h2>DESCRIPTION</h2>

      <p><code class="function">timer_create</code>() creates a new
      per-process interval timer. The ID of the new timer is
      returned in the buffer pointed to by <em class="parameter"><code>timerid</code></em>, which must be a
      non-null pointer. This ID is unique within the process, until
      the timer is deleted. The new timer is initially
      disarmed.</p>

      <p>The <em class="parameter"><code>clockid</code></em>
      argument specifies the clock that the new timer uses to
      measure time. It can be specified as one of the following
      values:</p>

      <div class="variablelist">
        <dl class="variablelist">
          <dt><span class="term"><code class="constant">CLOCK_REALTIME</code></span></dt>

          <dd>
            <p>A settable system-wide real-time clock.</p>
          </dd>

          <dt><span class="term"><code class="constant">CLOCK_MONOTONIC</code></span></dt>

          <dd>
            <p>A nonsettable monotonically increasing clock that
            measures time from some unspecified point in the past
            that does not change after system startup.</p>
          </dd>

          <dt><span class="term"><code class="constant">CLOCK_PROCESS_CPUTIME_ID</code> (since Linux
          2.6.12)</span></dt>

          <dd>
            <p>A clock that measures (user and system) CPU time
            consumed by (all of the threads in) the calling
            process.</p>
          </dd>

          <dt><span class="term"><code class="constant">CLOCK_THREAD_CPUTIME_ID</code> (since Linux
          2.6.12)</span></dt>

          <dd>
            <p>A clock that measures (user and system) CPU time
            consumed by the calling thread.</p>
          </dd>
        </dl>
      </div>

      <p>As well as the above values, <em class="parameter"><code>clockid</code></em> can be specified as the
      <em class="parameter"><code>clockid</code></em> returned by a
      call to <a class="link" href="../htmlman3/clock_getcpuclockid.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">clock_getcpuclockid</span>(3)</span></a> or
      <a class="link" href="../htmlman3/pthread_getcpuclockid.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pthread_getcpuclockid</span>(3)</span></a>.</p>

      <p>The <em class="parameter"><code>sevp</code></em> argument
      points to a <span class="structname">sigevent</span>
      structure that specifies how the caller should be notified
      when the timer expires. For the definition and general
      details of this structure, see <a class="link" href="../htmlman7/sigevent.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sigevent</span>(7)</span></a>.</p>

      <p>The <em class="replaceable"><code>sevp.sigev_notify</code></em> field can
      have the following values:</p>

      <div class="variablelist">
        <dl class="variablelist">
          <dt><span class="term"><code class="constant">SIGEV_NONE</code></span></dt>

          <dd>
            <p>Don't asynchronously notify when the timer expires.
            Progress of the timer can be monitored using <a class="link" href="../htmlman2/timer_settime.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">timer_gettime</span>(2)</span></a>.</p>
          </dd>

          <dt><span class="term"><code class="constant">SIGEV_SIGNAL</code></span></dt>

          <dd>
            <p>Upon timer expiration, generate the signal
            <em class="replaceable"><code>sigev_signo</code></em>
            for the process. See <a class="link" href="../htmlman7/sigevent.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sigevent</span>(7)</span></a> for
            general details. The <em class="replaceable"><code>si_code</code></em> field of the
            <span class="type">siginfo_t</span> structure will be
            set to <code class="constant">SI_TIMER</code>. At any
            point in time, at most one signal is queued to the
            process for a given timer; see <a class="link" href="../htmlman2/timer_getoverrun.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">timer_getoverrun</span>(2)</span></a>
            for more details.</p>
          </dd>

          <dt><span class="term"><code class="constant">SIGEV_THREAD</code></span></dt>

          <dd>
            <p>Upon timer expiration, invoke <em class="replaceable"><code>sigev_notify_function</code></em>
            as if it were the start function of a new thread. See
            <a class="link" href="../htmlman7/sigevent.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sigevent</span>(7)</span></a> for
            details.</p>
          </dd>

          <dt><span class="term"><code class="constant">SIGEV_THREAD_ID</code>
          (Linux-specific)</span></dt>

          <dd>
            <p>As for <code class="constant">SIGEV_SIGNAL</code>,
            but the signal is targeted at the thread whose ID is
            given in <em class="replaceable"><code>sigev_notify_thread_id</code></em>,
            which must be a thread in the same process as the
            caller. The <em class="replaceable"><code>sigev_notify_thread_id</code></em>
            field specifies a kernel thread ID, that is, the value
            returned by <a class="link" href="../htmlman2/clone.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">clone</span>(2)</span></a> or <a class="link" href="../htmlman2/gettid.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">gettid</span>(2)</span></a>. This flag
            is intended only for use by threading libraries.</p>
          </dd>
        </dl>
      </div>

      <p>Specifying <em class="parameter"><code>sevp</code></em> as
      NULL is equivalent to specifying a pointer to a <span class="structname">sigevent</span> structure in which <em class="replaceable"><code>sigev_notify</code></em> is <code class="constant">SIGEV_SIGNAL</code>, <em class="replaceable"><code>sigev_signo</code></em> is <code class="constant">SIGALRM</code>, and <em class="replaceable"><code>sigev_value.sival_int</code></em> is the
      timer ID.</p>
    </div>

    <div class="refsect1">
      <a id="timer-create-2_sect2" name="timer-create-2_sect2" shape="rect"> </a>

      <h2>RETURN VALUE</h2>

      <p>On success, <code class="function">timer_create</code>()
      returns 0, and the ID of the new timer is placed in
      *<em class="parameter"><code>timerid</code></em>. On failure,
      −1 is returned, and <code class="varname">errno</code>
      is set to indicate the error.</p>
    </div>

    <div class="refsect1">
      <a id="timer-create-2_sect3" name="timer-create-2_sect3" shape="rect"> </a>

      <h2>ERRORS</h2>

      <div class="variablelist">
        <dl class="variablelist">
          <dt><span class="term"><span class="errorname">EAGAIN</span></span></dt>

          <dd>
            <p>Temporary error during kernel allocation of timer
            structures.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EINVAL</span></span></dt>

          <dd>
            <p>Clock ID, <em class="replaceable"><code>sigev_notify</code></em>,
            <em class="replaceable"><code>sigev_signo</code></em>,
            or <em class="replaceable"><code>sigev_notify_thread_id</code></em>
            is invalid.</p>
          </dd>

          <dt><span class="term"><span class="errorname">ENOMEM</span></span></dt>

          <dd>
            <p>Could not allocate memory.</p>
          </dd>
        </dl>
      </div>
    </div>

    <div class="refsect1">
      <a id="timer-create-2_sect4" name="timer-create-2_sect4" shape="rect"> </a>

      <h2>VERSIONS</h2>

      <p>This system call is available since Linux 2.6.</p>
    </div>

    <div class="refsect1">
      <a id="timer-create-2_sect5" name="timer-create-2_sect5" shape="rect"> </a>

      <h2>CONFORMING TO</h2>

      <p>POSIX.1-2001.</p>
    </div>

    <div class="refsect1">
      <a id="timer-create-2_sect6" name="timer-create-2_sect6" shape="rect"> </a>

      <h2>NOTES</h2>

      <p>A program may create multiple interval timers using
      <code class="function">timer_create</code>().</p>

      <p>Timers are not inherited by the child of a <a class="link" href="../htmlman2/fork.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fork</span>(2)</span></a>, and are disarmed
      and deleted during an <a class="link" href="../htmlman2/execve.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">execve</span>(2)</span></a>.</p>

      <p>The kernel preallocates a "queued real-time signal" for
      each timer created using <code class="function">timer_create</code>(). Consequently, the number of
      timers is limited by the <code class="constant">RLIMIT_SIGPENDING</code> resource limit (see
      <a class="link" href="../htmlman2/getrlimit.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">setrlimit</span>(2)</span></a>).</p>

      <p>The timers created by <code class="function">timer_create</code>() are commonly known as "POSIX
      (interval) timers". The POSIX timers API consists of the
      following interfaces:</p>

      <div class="itemizedlist">
        <ul class="itemizedlist" style="list-style-type: disc;">
          <li class="listitem">
            <p><code class="function">timer_create</code>(): Create
            a timer.</p>
          </li>

          <li class="listitem">
            <p><a class="link" href="../htmlman2/timer_settime.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">timer_settime</span>(2)</span></a>: Arm
            (start) or disarm (stop) a timer.</p>
          </li>

          <li class="listitem">
            <p><a class="link" href="../htmlman2/timer_settime.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">timer_gettime</span>(2)</span></a>:
            Fetch the time remaining until the next expiration of a
            timer, along with the interval setting of the
            timer.</p>
          </li>

          <li class="listitem">
            <p><a class="link" href="../htmlman2/timer_getoverrun.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">timer_getoverrun</span>(2)</span></a>:
            Return the overrun count for the last timer
            expiration.</p>
          </li>

          <li class="listitem">
            <p><a class="link" href="../htmlman2/timer_delete.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">timer_delete</span>(2)</span></a>:
            Disarm and delete a timer.</p>
          </li>
        </ul>
      </div>

      <p>Since Linux 3.10, the <code class="filename">/proc/[pid]/timers</code> file can be used to list
      the POSIX timers for the process with PID <em class="replaceable"><code>pid</code></em>. See <a class="link" href="../htmlman5/proc.5.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">proc</span>(5)</span></a> for further
      information.</p>

      <div class="refsect2">
        <a id="timer-create-2_sect7" name="timer-create-2_sect7" shape="rect"> </a>

        <h3>C library/kernel ABI differences</h3>

        <p>Part of the implementation of the POSIX timers API is
        provided by glibc. In particular:</p>

        <div class="itemizedlist">
          <ul class="itemizedlist" style="list-style-type: disc;">
            <li class="listitem">
              <p>Much of the functionality for <code class="constant">SIGEV_THREAD</code> is implemented within
              glibc, rather than the kernel. (This is necessarily
              so, since the thread involved in handling the
              notification is one that must be managed by the C
              library POSIX threads implementation.) Although the
              notification delivered to the process is via a
              thread, internally the NPTL implementation uses a
              <em class="replaceable"><code>sigev_notify</code></em> value of
              <code class="constant">SIGEV_THREAD_ID</code> along
              with a real-time signal that is reserved by the
              implementation (see <a class="link" href="../htmlman7/nptl.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">nptl</span>(7)</span></a>).</p>
            </li>

            <li class="listitem">
              <p>The implementation of the default case where
              <em class="replaceable"><code>evp</code></em> is NULL
              is handled inside glibc, which invokes the underlying
              system call with a suitably populated <span class="structname">sigevent</span> structure.</p>
            </li>

            <li class="listitem">
              <p>The timer IDs presented at user level are
              maintained by glibc, which maps these IDs to the
              timer IDs employed by the kernel.</p>
            </li>
          </ul>
        </div>

        <p>The POSIX timers system calls first appeared in Linux
        2.6. Prior to this, glibc provided an incomplete user-space
        implementation (<code class="constant">CLOCK_REALTIME</code> timers only) using POSIX
        threads, and in glibc versions before 2.17, the
        implementation falls back to this technique on systems
        running pre-2.6 Linux kernels.</p>
      </div>
    </div>

    <div class="refsect1">
      <a id="timer-create-2_sect8" name="timer-create-2_sect8" shape="rect"> </a>

      <h2>EXAMPLE</h2>

      <p>The program below takes two arguments: a sleep period in
      seconds, and a timer frequency in nanoseconds. The program
      establishes a handler for the signal it uses for the timer,
      blocks that signal, creates and arms a timer that expires
      with the given frequency, sleeps for the specified number of
      seconds, and then unblocks the timer signal. Assuming that
      the timer expired at least once while the program slept, the
      signal handler will be invoked, and the handler displays some
      information about the timer notification. The program
      terminates after one invocation of the signal handler.</p>

      <p>In the following example run, the program sleeps for 1
      second, after creating a timer that has a frequency of 100
      nanoseconds. By the time the signal is unblocked and
      delivered, there have been around ten million overruns.</p>

      <div class="blockquote">
        <blockquote class="blockquote">
          <div class="informalexample">
            <pre class="programlisting" xml:space="preserve">
$ <span class="emphasis"><em>./a.out 1 100</em></span>
Establishing handler for signal 34
Blocking signal 34
timer ID is 0x804c008
Sleeping for 1 seconds
Unblocking signal 34
Caught signal 34
    sival_ptr = 0xbfb174f4;     *sival_ptr = 0x804c008
    overrun count = 10004886
</pre>
          </div>
        </blockquote>
      </div>

      <div class="refsect2">
        <a id="timer-create-2_sect9" name="timer-create-2_sect9" shape="rect"> </a>

        <h3>Program source</h3>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;time.h&gt;

#define CLOCKID CLOCK_REALTIME
#define SIG SIGRTMIN

#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)

static void
print_siginfo(siginfo_t *si)
{
    timer_t *tidp;
    int or;

    tidp = si−&gt;si_value.sival_ptr;

    printf("    sival_ptr = %p; ", si−&gt;si_value.sival_ptr);
    printf("    *sival_ptr = 0x%lx\n", (long) *tidp);

    or = timer_getoverrun(*tidp);
    if (or == −1)
        errExit("timer_getoverrun");
    else
        printf("    overrun count = %d\n", or);
}

static void
handler(int sig, siginfo_t *si, void *uc)
{
    /* Note: calling printf() from a signal handler is not
       strictly correct, since printf() is not async−signal−safe;
       see signal(7) */

    printf("Caught signal %d\n", sig);
    print_siginfo(si);
    signal(sig, SIG_IGN);
}

int
main(int argc, char *argv[])
{
    timer_t timerid;
    struct sigevent sev;
    struct itimerspec its;
    long long freq_nanosecs;
    sigset_t mask;
    struct sigaction sa;

    if (argc != 3) {
        fprintf(stderr, "Usage: %s &lt;sleep−secs&gt; &lt;freq−nanosecs&gt;\n",
                argv[0]);
        exit(EXIT_FAILURE);
    }

    /* Establish handler for timer signal */

    printf("Establishing handler for signal %d\n", SIG);
    sa.sa_flags = SA_SIGINFO;
    sa.sa_sigaction = handler;
    sigemptyset(&amp;sa.sa_mask);
    if (sigaction(SIG, &amp;sa, NULL) == −1)
        errExit("sigaction");

    /* Block timer signal temporarily */

    printf("Blocking signal %d\n", SIG);
    sigemptyset(&amp;mask);
    sigaddset(&amp;mask, SIG);
    if (sigprocmask(SIG_SETMASK, &amp;mask, NULL) == −1)
        errExit("sigprocmask");

    /* Create the timer */

    sev.sigev_notify = SIGEV_SIGNAL;
    sev.sigev_signo = SIG;
    sev.sigev_value.sival_ptr = &amp;timerid;
    if (timer_create(CLOCKID, &amp;sev, &amp;timerid) == −1)
        errExit("timer_create");

    printf("timer ID is 0x%lx\n", (long) timerid);

    /* Start the timer */

    freq_nanosecs = atoll(argv[2]);
    its.it_value.tv_sec = freq_nanosecs / 1000000000;
    its.it_value.tv_nsec = freq_nanosecs % 1000000000;
    its.it_interval.tv_sec = its.it_value.tv_sec;
    its.it_interval.tv_nsec = its.it_value.tv_nsec;

    if (timer_settime(timerid, 0, &amp;its, NULL) == −1)
         errExit("timer_settime");

    /* Sleep for a while; meanwhile, the timer may expire
       multiple times */

    printf("Sleeping for %d seconds\n", atoi(argv[1]));
    sleep(atoi(argv[1]));

    /* Unlock the timer signal, so that timer notification
       can be delivered */

    printf("Unblocking signal %d\n", SIG);
    if (sigprocmask(SIG_UNBLOCK, &amp;mask, NULL) == −1)
        errExit("sigprocmask");

    exit(EXIT_SUCCESS);
}
</pre>
        </div>
      </div>
    </div>

    <div class="refsect1">
      <a id="timer-create-2_sect10" name="timer-create-2_sect10" shape="rect"> </a>

      <h2>SEE ALSO</h2>

      <p><a class="link" href="../htmlman2/clock_getres.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">clock_gettime</span>(2)</span></a>, <a class="link" href="../htmlman2/getitimer.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">setitimer</span>(2)</span></a>, <a class="link" href="../htmlman2/timer_delete.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">timer_delete</span>(2)</span></a>, <a class="link" href="../htmlman2/timer_getoverrun.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">timer_getoverrun</span>(2)</span></a>,
      <a class="link" href="../htmlman2/timer_settime.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">timer_settime</span>(2)</span></a>, <a class="link" href="../htmlman2/timerfd_create.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">timerfd_create</span>(2)</span></a>,
      <a class="link" href="../htmlman3/clock_getcpuclockid.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">clock_getcpuclockid</span>(3)</span></a>,
      <a class="link" href="../htmlman3/pthread_getcpuclockid.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pthread_getcpuclockid</span>(3)</span></a>,
      <a class="link" href="../htmlman7/pthreads.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pthreads</span>(7)</span></a>, <a class="link" href="../htmlman7/sigevent.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sigevent</span>(7)</span></a>, <a class="link" href="../htmlman7/signal.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">signal</span>(7)</span></a>, <a class="link" href="../htmlman7/time.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">time</span>(7)</span></a></p>
    </div>

    <div class="colophon">
      <a id="timer-create-2_sect11" name="timer-create-2_sect11" shape="rect"> </a>

      <h2>COLOPHON</h2>

      <p>This page is part of release 4.00 of the Linux <em class="replaceable"><code>man-pages</code></em> project. A
      description of the project, information about reporting bugs,
      and the latest version of this page, can be found at
      http://www.kernel.org/doc/man−pages/.</p>

      <div class="license">
        <table style="border-collapse: collapse;">
          <colgroup span="1">
            <col span="1" />
          </colgroup>

          <tbody>
            <tr>
              <td style="" rowspan="1" colspan="1">
                <div class="literallayout">
                  <br />
                    Copyright (c) 2009 Linux Foundation, written by Michael Kerrisk<br />

                      &lt;mtk.manpages<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>gmail.com&gt;<br />

                  <br />
                  %%%LICENSE_START(VERBATIM)<br />
                  Permission is granted to make and distribute verbatim copies of this<br />

                  manual provided the copyright notice and this permission notice are<br />

                  preserved on all copies.<br />
                  <br />
                  Permission is granted to copy and distribute modified versions of this<br />

                  manual under the conditions for verbatim copying, provided that the<br />

                  entire resulting derived work is distributed under the terms of a<br />

                  permission notice identical to this one.<br />

                  <br />
                  Since the Linux kernel and libraries are constantly changing, this<br />

                  manual page may be incorrect or out-of-date.  The author(s) assume no<br />

                  responsibility for errors or omissions, or for damages resulting from<br />

                  the use of the information contained herein.  The author(s) may not<br />

                  have taken the same level of care in the production of this manual,<br />

                  which is licensed free of charge, as they might when working<br />

                  professionally.<br />
                  <br />
                  Formatted or processed versions of this manual, if unaccompanied by<br />

                  the source, must acknowledge the copyright and authors of this work.<br />

                  %%%LICENSE_END<br />
                  <br />
                  FIXME Linux 2.6.39 adds CLOCK_BOOTTIME, which needs be documented<br />

                  Does this also affect timerfd_create()?<br />

                  <br />
                  FIXME Linux 3.0 adds CLOCK_BOOTTIME_ALARM and CLOCK_REALTIME_ALARM,<br />

                  which need be documented<br />
                  Does this also affect timerfd_create()?<br />
                  
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</body>
</html>
