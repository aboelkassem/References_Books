<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

  <title>st(4) — Linux manual pages</title>
  <link rel="stylesheet" type="text/css" href="../stylesheet/manpages.css" />
  
  <link rel="home" href="../index.html" title="st(4) — Linux manual pages" />
  <script type="text/javascript" src="../stylesheet/manpages.js" xml:space="preserve">
</script>
  <link rel="icon" href="../stylesheet/icon.gif" type="image/gif" />
</head>

<body onload="javascript:init()">
  <div class="navheader">
    <table width="100%">
      <tbody>
        <tr>
          <td style="width: 33%" rowspan="1" colspan="1"><a href="../index.html" shape="rect">Linux
          manual pages</a></td>

          <th rowspan="1" colspan="1"><a href="../index4.html" shape="rect">Section 4</a></th>

          <td style="width: 33%" rowspan="1" colspan="1"> </td>
        </tr>
      </tbody>
    </table>
    <hr />
  </div>

  <div class="refentry">
    <a id="st.4" name="st.4" shape="rect"> </a>

    <div class="titlepage"> </div>

    <div class="refnamediv">
      <h2>Name</h2>

      <p>st — SCSI tape device</p>
    </div>

    <div class="refsynopsisdiv">
      <h2>Synopsis</h2>

      <div class="funcsynopsis">
        <pre class="funcsynopsisinfo" xml:space="preserve">
#include &lt;sys/mtio.h&gt;
</pre>

        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>ioctl</strong>(</code></td>

            <td rowspan="1" colspan="1">int <var class="pdparam">fd</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">request</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">(void *)<var class="pdparam">arg3</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <pre class="funcsynopsisinfo" xml:space="preserve">
/* arg3 is optional */
</pre>

        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>ioctl</strong>(</code></td>

            <td rowspan="1" colspan="1">int <var class="pdparam">fd</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1"><var class="pdparam">MTIOCTOP</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">(struct mtop *)<var class="pdparam">mt_cmd</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>ioctl</strong>(</code></td>

            <td rowspan="1" colspan="1">int <var class="pdparam">fd</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1"><var class="pdparam">MTIOCGET</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">(struct mtget *)<var class="pdparam">mt_status</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>ioctl</strong>(</code></td>

            <td rowspan="1" colspan="1">int <var class="pdparam">fd</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1"><var class="pdparam">MTIOCPOS</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">(struct mtpos *)<var class="pdparam">mt_pos</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>
    </div>

    <div class="refsect1">
      <a id="st-4_sect1" name="st-4_sect1" shape="rect"> </a>

      <h2>DESCRIPTION</h2>

      <p>The <code class="function">st</code> driver provides the
      interface to a variety of SCSI tape devices. Currently, the
      driver takes control of all detected devices of type
      <span class="quote">“<span class="quote">sequential-access</span>”</span>. The
      <code class="function">st</code> driver uses major device
      number 9.</p>

      <p>Each device uses eight minor device numbers. The lowermost
      five bits in the minor numbers are assigned sequentially in
      the order of detection. In the 2.6 kernel, the bits above the
      eight lowermost bits are concatenated to the five lowermost
      bits to form the tape number. The minor numbers can be
      grouped into two sets of four numbers: the principal
      (auto-rewind) minor device numbers, <code class="literal">n</code>, and the <span class="quote">“<span class="quote">no-rewind</span>”</span> device numbers,
      (<code class="literal">n</code> + 128). Devices opened using
      the principal device number will be sent a <code class="constant">REWIND</code> command when they are closed.
      Devices opened using the <span class="quote">“<span class="quote">no-rewind</span>”</span> device number will
      not. (Note that using an auto-rewind device for positioning
      the tape with, for instance, mt does not lead to the desired
      result: the tape is rewound after the mt command and the next
      command starts from the beginning of the tape).</p>

      <p>Within each group, four minor numbers are available to
      define devices with different characteristics (block size,
      compression, density, etc.) When the system starts up, only
      the first device is available. The other three are activated
      when the default characteristics are defined (see below). (By
      changing compile-time constants, it is possible to change the
      balance between the maximum number of tape drives and the
      number of minor numbers for each drive. The default
      allocation allows control of 32 tape drives. For instance, it
      is possible to control up to 64 tape drives with two minor
      numbers for different options.)</p>

      <p>Devices are typically created by:</p>

      <div class="blockquote">
        <blockquote class="blockquote">
          <div class="informalexample">
            <pre class="programlisting" xml:space="preserve">
mknod −m 666 /dev/st0 c 9 0
mknod −m 666 /dev/st0l c 9 32
mknod −m 666 /dev/st0m c 9 64
mknod −m 666 /dev/st0a c 9 96
mknod −m 666 /dev/nst0 c 9 128
mknod −m 666 /dev/nst0l c 9 160
mknod −m 666 /dev/nst0m c 9 192
mknod −m 666 /dev/nst0a c 9 224
</pre>
          </div>
        </blockquote>
      </div>

      <p>There is no corresponding block device.</p>

      <p>The driver uses an internal buffer that has to be large
      enough to hold at least one tape block. In kernels before
      2.1.121, the buffer is allocated as one contiguous block.
      This limits the block size to the largest contiguous block of
      memory the kernel allocator can provide. The limit is
      currently 128 kB for 32-bit architectures and 256 kB for
      64-bit architectures. In newer kernels the driver allocates
      the buffer in several parts if necessary. By default, the
      maximum number of parts is 16. This means that the maximum
      block size is very large (2 MB if allocation of 16 blocks of
      128 kB succeeds).</p>

      <p>The driver's internal buffer size is determined by a
      compile-time constant which can be overridden with a kernel
      startup option. In addition to this, the driver tries to
      allocate a larger temporary buffer at run time if necessary.
      However, run-time allocation of large contiguous blocks of
      memory may fail and it is advisable not to rely too much on
      dynamic buffer allocation with kernels older than 2.1.121
      (this applies also to demand-loading the driver with kerneld
      or kmod).</p>

      <p>The driver does not specifically support any tape drive
      brand or model. After system start-up the tape device options
      are defined by the drive firmware. For example, if the drive
      firmware selects fixed-block mode, the tape device uses
      fixed-block mode. The options can be changed with explicit
      <a class="link" href="../htmlman2/ioctl.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">ioctl</span>(2)</span></a> calls and remain
      in effect when the device is closed and reopened. Setting the
      options affects both the auto-rewind and the nonrewind
      device.</p>

      <p>Different options can be specified for the different
      devices within the subgroup of four. The options take effect
      when the device is opened. For example, the system
      administrator can define one device that writes in
      fixed-block mode with a certain block size, and one which
      writes in variable-block mode (if the drive supports both
      modes).</p>

      <p>The driver supports <span class="emphasis"><em>tape
      partitions</em></span> if they are supported by the drive.
      (Note that the tape partitions have nothing to do with disk
      partitions. A partitioned tape can be seen as several logical
      tapes within one medium.) Partition support has to be enabled
      with an <a class="link" href="../htmlman2/ioctl.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">ioctl</span>(2)</span></a>. The tape location
      is preserved within each partition across partition changes.
      The partition used for subsequent tape operations is selected
      with an <a class="link" href="../htmlman2/ioctl.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">ioctl</span>(2)</span></a>. The partition
      switch is executed together with the next tape operation in
      order to avoid unnecessary tape movement. The maximum number
      of partitions on a tape is defined by a compile-time constant
      (originally four). The driver contains an <a class="link" href="../htmlman2/ioctl.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">ioctl</span>(2)</span></a> that can format a
      tape with either one or two partitions.</p>

      <p>Device <code class="filename">/dev/tape</code> is usually
      created as a hard or soft link to the default tape device on
      the system.</p>

      <p>Starting from kernel 2.6.2, the driver exports in the
      sysfs directory <code class="filename">/sys/class/scsi_tape</code> the attached devices
      and some parameters assigned to the devices.</p>

      <div class="refsect2">
        <a id="st-4_sect2" name="st-4_sect2" shape="rect"> </a>

        <h3>Data transfer</h3>

        <p>The driver supports operation in both fixed-block mode
        and variable-block mode (if supported by the drive). In
        fixed-block mode the drive writes blocks of the specified
        size and the block size is not dependent on the byte counts
        of the write system calls. In variable-block mode one tape
        block is written for each write call and the byte count
        determines the size of the corresponding tape block. Note
        that the blocks on the tape don't contain any information
        about the writing mode: when reading, the only important
        thing is to use commands that accept the block sizes on the
        tape.</p>

        <p>In variable-block mode the read byte count does not have
        to match the tape block size exactly. If the byte count is
        larger than the next block on tape, the driver returns the
        data and the function returns the actual block size. If the
        block size is larger than the byte count, the requested
        amount of data from the start of the block is returned and
        the rest of the block is discarded.</p>

        <p>In fixed-block mode the read byte counts can be
        arbitrary if buffering is enabled, or a multiple of the
        tape block size if buffering is disabled. Kernels before
        2.1.121 allow writes with arbitrary byte count if buffering
        is enabled. In all other cases (kernel before 2.1.121 with
        buffering disabled or newer kernel) the write byte count
        must be a multiple of the tape block size.</p>

        <p>In the 2.6 kernel, the driver tries to use direct
        transfers between the user buffer and the device. If this
        is not possible, the driver's internal buffer is used. The
        reasons for not using direct transfers include improper
        alignment of the user buffer (default is 512 bytes but this
        can be changed by the HBA driver), one or more pages of the
        user buffer not reachable by the SCSI adapter, and so
        on.</p>

        <p>A filemark is automatically written to tape if the last
        tape operation before close was a write.</p>

        <p>When a filemark is encountered while reading, the
        following happens. If there are data remaining in the
        buffer when the filemark is found, the buffered data is
        returned. The next read returns zero bytes. The following
        read returns data from the next file. The end of recorded
        data is signaled by returning zero bytes for two
        consecutive read calls. The third read returns an
        error.</p>
      </div>

      <div class="refsect2">
        <a id="st-4_sect3" name="st-4_sect3" shape="rect"> </a>

        <h3>Ioctls</h3>

        <p>The driver supports three <a class="link" href="../htmlman2/ioctl.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">ioctl</span>(2)</span></a> requests.
        Requests not recognized by the <code class="function">st</code> driver are passed to the <code class="constant">SCSI</code> driver. The definitions below are
        from <code class="filename">/usr/include/linux/mtio.h<code class="literal">:</code></code></p>
      </div>

      <div class="refsect2">
        <a id="st-4_sect4" name="st-4_sect4" shape="rect"> </a>

        <h3>MTIOCTOP — perform a tape operation</h3>

        <p>This request takes an argument of type <span class="emphasis"><em>(struct mtop *)</em></span>. Not all drives
        support all operations. The driver returns an <span class="errorname">EIO</span> error if the drive rejects an
        operation.</p>

        <div class="blockquote">
          <blockquote class="blockquote">
            <div class="structdef">
              <table style="border-collapse: collapse;">
                <colgroup span="1">
                  <col class="c1" span="1" />
                  <col class="c2" span="1" />
                  <col class="c3" span="1" />
                  <col class="c4" span="1" />
                  <col class="c5" span="1" />
                </colgroup>

                <tbody>
                  <tr>
                    <td style="" colspan="5" align="left" rowspan="1">
                      <div class="literallayout">
                        
                        /* Structure for MTIOCTOP \- mag tape op command: */
                      </div>
                    </td>
                  </tr>

                  <tr>
                    <td style="" colspan="5" rowspan="1"> </td>
                  </tr>

                  <tr>
                    <td class="structdefhdr" style="" align="left" rowspan="1" colspan="1">
                    struct</td>

                    <td class="structdefhdr" style="" colspan="4" align="left" rowspan="1"><span class="structname">mtop</span> {</td>
                  </tr>

                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>

                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">short</span></td>

                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>

                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>mt_op</code></em>;</td>

                    <td style="" align="left" rowspan="1" colspan="1">
                      <div class="literallayout">
                        
                        /* operations defined below */
                      </div>
                    </td>
                  </tr>

                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>

                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">int</span></td>

                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>

                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>mt_count</code></em>;</td>

                    <td style="" align="left" rowspan="1" colspan="1">
                      <div class="literallayout">
                        
                        /* how many of them */
                      </div>
                    </td>
                  </tr>

                  <tr>
                    <td class="structdefftr" style="" colspan="5" align="left" rowspan="1">};</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </blockquote>
        </div>

        <p>Magnetic Tape operations for normal tape use:</p>

        <div class="variablelist">
          <dl class="variablelist">
            <dt><span class="term"><code class="constant">MTBSF</code></span></dt>

            <dd>
              <p>Backward space over <em class="parameter"><code>mt_count</code></em> filemarks.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTBSFM</code></span></dt>

            <dd>
              <p>Backward space over <em class="parameter"><code>mt_count</code></em> filemarks.
              Reposition the tape to the EOT side of the last
              filemark.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTBSR</code></span></dt>

            <dd>
              <p>Backward space over <em class="parameter"><code>mt_count</code></em> records (tape
              blocks).</p>
            </dd>

            <dt><span class="term"><code class="constant">MTBSS</code></span></dt>

            <dd>
              <p>Backward space over <em class="parameter"><code>mt_count</code></em> setmarks.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTCOMPRESSION</code></span></dt>

            <dd>
              <p>Enable compression of tape data within the drive
              if <em class="parameter"><code>mt_count</code></em>
              is nonzero and disable compression if <em class="parameter"><code>mt_count</code></em> is zero. This
              command uses the MODE page 15 supported by most
              DATs.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTEOM</code></span></dt>

            <dd>
              <p>Go to the end of the recorded media (for appending
              files).</p>
            </dd>

            <dt><span class="term"><code class="constant">MTERASE</code></span></dt>

            <dd>
              <p>Erase tape. With 2.6 kernel, short erase (mark
              tape empty) is performed if the argument is zero.
              Otherwise, long erase (erase all) is done.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTFSF</code></span></dt>

            <dd>
              <p>Forward space over <em class="parameter"><code>mt_count</code></em> filemarks.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTFSFM</code></span></dt>

            <dd>
              <p>Forward space over <em class="parameter"><code>mt_count</code></em> filemarks.
              Reposition the tape to the BOT side of the last
              filemark.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTFSR</code></span></dt>

            <dd>
              <p>Forward space over <em class="parameter"><code>mt_count</code></em> records (tape
              blocks).</p>
            </dd>

            <dt><span class="term"><code class="constant">MTFSS</code></span></dt>

            <dd>
              <p>Forward space over <em class="parameter"><code>mt_count</code></em> setmarks.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTLOAD</code></span></dt>

            <dd>
              <p>Execute the SCSI load command. A special case is
              available for some HP autoloaders. If <em class="parameter"><code>mt_count</code></em> is the
              constant <code class="constant">MT_ST_HPLOADER_OFFSET</code> plus a
              number, the number is sent to the drive to control
              the autoloader.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTLOCK</code></span></dt>

            <dd>
              <p>Lock the tape drive door.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTMKPART</code></span></dt>

            <dd>
              <p>Format the tape into one or two partitions. If
              <em class="parameter"><code>mt_count</code></em> is
              nonzero, it gives the size of the first partition and
              the second partition contains the rest of the tape.
              If <em class="parameter"><code>mt_count</code></em>
              is zero, the tape is formatted into one partition.
              This command is not allowed for a drive unless the
              partition support is enabled for the drive (see
              <code class="constant">MT_ST_CAN_PARTITIONS</code>
              below).</p>
            </dd>

            <dt><span class="term"><code class="constant">MTNOP</code></span></dt>

            <dd>
              <p>No op—flushes the driver's buffer as a side
              effect. Should be used before reading status with
              <em class="parameter"><code>MTIOCGET</code></em>.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTOFFL</code></span></dt>

            <dd>
              <p>Rewind and put the drive off line.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTRESET</code></span></dt>

            <dd>
              <p>Reset drive.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTRETEN</code></span></dt>

            <dd>
              <p>Re-tension tape.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTREW</code></span></dt>

            <dd>
              <p>Rewind.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTSEEK</code></span></dt>

            <dd>
              <p>Seek to the tape block number specified in
              <em class="parameter"><code>mt_count</code></em>.
              This operation requires either a SCSI-2 drive that
              supports the <code class="constant">LOCATE</code>
              command (device-specific address) or a
              Tandberg-compatible SCSI-1 drive (Tandberg, Archive
              Viper, Wangtek, ...). The block number should be one
              that was previously returned by <em class="parameter"><code>MTIOCPOS</code></em> if
              device-specific addresses are used.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTSETBLK</code></span></dt>

            <dd>
              <p>Set the drive's block length to the value
              specified in <em class="parameter"><code>mt_count</code></em>. A block
              length of zero sets the drive to variable block size
              mode.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTSETDENSITY</code></span></dt>

            <dd>
              <p>Set the tape density to the code in <em class="parameter"><code>mt_count</code></em>. The density
              codes supported by a drive can be found from the
              drive documentation.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTSETPART</code></span></dt>

            <dd>
              <p>The active partition is switched to <em class="parameter"><code>mt_count</code></em>. The
              partitions are numbered from zero. This command is
              not allowed for a drive unless the partition support
              is enabled for the drive (see <code class="constant">MT_ST_CAN_PARTITIONS</code> below).</p>
            </dd>

            <dt><span class="term"><code class="constant">MTUNLOAD</code></span></dt>

            <dd>
              <p>Execute the SCSI unload command (does not eject
              the tape).</p>
            </dd>

            <dt><span class="term"><code class="constant">MTUNLOCK</code></span></dt>

            <dd>
              <p>Unlock the tape drive door.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTWEOF</code></span></dt>

            <dd>
              <p>Write <em class="parameter"><code>mt_count</code></em> filemarks.</p>
            </dd>

            <dt><span class="term"><code class="constant">MTWSM</code></span></dt>

            <dd>
              <p>Write <em class="parameter"><code>mt_count</code></em> setmarks.</p>
            </dd>
          </dl>
        </div>

        <p>Magnetic Tape operations for setting of device options
        (by the superuser):</p>

        <div class="variablelist">
          <dl class="variablelist">
            <dt><span class="term"><code class="constant">MTSETDRVBUFFER</code></span></dt>

            <dd>
              <p>Set various drive and driver options according to
              bits encoded in <em class="parameter"><code>mt_count</code></em>. These consist
              of the drive's buffering mode, a set of Boolean
              driver options, the buffer write threshold, defaults
              for the block size and density, and timeouts (only in
              kernels 2.1 and later). A single operation can affect
              only one item in the list above (the Booleans counted
              as one item.)</p>

              <p>A value having zeros in the high-order 4 bits will
              be used to set the drive's buffering mode. The
              buffering modes are:</p>

              <div class="blockquote">
                <blockquote class="blockquote">
                  <div class="variablelist">
                    <dl class="variablelist">
                      <dt><span class="term"><code class="constant">0</code></span></dt>

                      <dd>
                        <p>The drive will not report <code class="constant">GOOD</code> status on write
                        commands until the data blocks are actually
                        written to the medium.</p>
                      </dd>

                      <dt><span class="term"><code class="constant">1</code></span></dt>

                      <dd>
                        <p>The drive may report <code class="constant">GOOD</code> status on write
                        commands as soon as all the data has been
                        transferred to the drive's internal
                        buffer.</p>
                      </dd>

                      <dt><span class="term"><code class="constant">2</code></span></dt>

                      <dd>
                        <p>The drive may report <code class="constant">GOOD</code> status on write
                        commands as soon as (a) all the data has
                        been transferred to the drive's internal
                        buffer, and (b) all buffered data from
                        different initiators has been successfully
                        written to the medium.</p>
                      </dd>
                    </dl>
                  </div>
                </blockquote>
              </div>

              <p>To control the write threshold the value in
              <em class="parameter"><code>mt_count</code></em> must
              include the constant <code class="constant">MT_ST_WRITE_THRESHOLD</code> bitwise ORed
              with a block count in the low 28 bits. The block
              count refers to 1024-byte blocks, not the physical
              block size on the tape. The threshold cannot exceed
              the driver's internal buffer size (see DESCRIPTION,
              above).</p>

              <p>To set and clear the Boolean options the value in
              <em class="parameter"><code>mt_count</code></em> must
              include one of the constants <code class="constant">MT_ST_BOOLEANS</code>, <code class="constant">MT_ST_SETBOOLEANS</code>, <code class="constant">MT_ST_CLEARBOOLEANS</code>, or
              <code class="constant">MT_ST_DEFBOOLEANS</code>
              bitwise ORed with whatever combination of the
              following options is desired. Using <code class="constant">MT_ST_BOOLEANS</code> the options can be
              set to the values defined in the corresponding bits.
              With <code class="constant">MT_ST_SETBOOLEANS</code>
              the options can be selectively set and with
              <code class="constant">MT_ST_DEFBOOLEANS</code>
              selectively cleared.</p>
            </dd>
          </dl>
        </div>

        <p>The default options for a tape device are set with
        <code class="constant">MT_ST_DEFBOOLEANS</code>. A
        nonactive tape device (e.g., device with minor 32 or 160)
        is activated when the default options for it are defined
        the first time. An activated device inherits from the
        device activated at start-up the options not set
        explicitly.</p>

        <p>The Boolean options are:</p>

        <div class="blockquote">
          <blockquote class="blockquote">
            <div class="variablelist">
              <dl class="variablelist">
                <dt><span class="term"><code class="constant">MT_ST_BUFFER_WRITES</code> (Default:
                true)</span></dt>

                <dd>
                  <p>Buffer all write operations in fixed-block
                  mode. If this option is false and the drive uses
                  a fixed block size, then all write operations
                  must be for a multiple of the block size. This
                  option must be set false to write reliable
                  multivolume archives.</p>
                </dd>

                <dt><span class="term"><code class="constant">MT_ST_ASYNC_WRITES</code> (Default:
                true)</span></dt>

                <dd>
                  <p>When this option is true, write operations
                  return immediately without waiting for the data
                  to be transferred to the drive if the data fits
                  into the driver's buffer. The write threshold
                  determines how full the buffer must be before a
                  new SCSI write command is issued. Any errors
                  reported by the drive will be held until the next
                  operation. This option must be set false to write
                  reliable multivolume archives.</p>
                </dd>

                <dt><span class="term"><code class="constant">MT_ST_READ_AHEAD</code> (Default:
                true)</span></dt>

                <dd>
                  <p>This option causes the driver to provide read
                  buffering and read-ahead in fixed-block mode. If
                  this option is false and the drive uses a fixed
                  block size, then all read operations must be for
                  a multiple of the block size.</p>
                </dd>

                <dt><span class="term"><code class="constant">MT_ST_TWO_FM</code> (Default:
                false)</span></dt>

                <dd>
                  <p>This option modifies the driver behavior when
                  a file is closed. The normal action is to write a
                  single filemark. If the option is true, the
                  driver will write two filemarks and backspace
                  over the second one.</p>

                  <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                    <table border="0" summary="Note">
                      <tr>
                        <td rowspan="2" align="center" valign="top" width="25" colspan="1"><img alt="[Note]" src="../stylesheet/note.png" /></td>

                        <th align="left" rowspan="1" colspan="1">Note</th>
                      </tr>

                      <tr>
                        <td align="left" valign="top" rowspan="1" colspan="1">
                          <p>This option should not be set true for
                          QIC tape drives since they are unable to
                          overwrite a filemark. These drives detect
                          the end of recorded data by testing for
                          blank tape rather than two consecutive
                          filemarks. Most other current drives also
                          detect the end of recorded data and using
                          two filemarks is usually necessary only
                          when interchanging tapes with some other
                          systems.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><span class="term"><code class="constant">MT_ST_DEBUGGING</code> (Default:
                false)</span></dt>

                <dd>
                  <p>This option turns on various debugging
                  messages from the driver (effective only if the
                  driver was compiled with <code class="constant">DEBUG</code> defined nonzero).</p>
                </dd>

                <dt><span class="term"><code class="constant">MT_ST_FAST_EOM</code> (Default:
                false)</span></dt>

                <dd>
                  <p>This option causes the <code class="constant">MTEOM</code> operation to be sent
                  directly to the drive, potentially speeding up
                  the operation but causing the driver to lose
                  track of the current file number normally
                  returned by the <em class="parameter"><code>MTIOCGET</code></em> request.
                  If <code class="constant">MT_ST_FAST_EOM</code>
                  is false, the driver will respond to an
                  <code class="constant">MTEOM</code> request by
                  forward spacing over files.</p>
                </dd>

                <dt><span class="term"><code class="constant">MT_ST_AUTO_LOCK</code> (Default:
                false)</span></dt>

                <dd>
                  <p>When this option is true, the drive door is
                  locked when the device is opened and unlocked
                  when it is closed.</p>
                </dd>

                <dt><span class="term"><code class="constant">MT_ST_DEF_WRITES</code> (Default:
                false)</span></dt>

                <dd>
                  <p>The tape options (block size, mode,
                  compression, etc.) may change when changing from
                  one device linked to a drive to another device
                  linked to the same drive depending on how the
                  devices are defined. This option defines when the
                  changes are enforced by the driver using
                  SCSI-commands and when the drives auto-detection
                  capabilities are relied upon. If this option is
                  false, the driver sends the SCSI-commands
                  immediately when the device is changed. If the
                  option is true, the SCSI-commands are not sent
                  until a write is requested. In this case, the
                  drive firmware is allowed to detect the tape
                  structure when reading and the SCSI-commands are
                  used only to make sure that a tape is written
                  according to the correct specification.</p>
                </dd>

                <dt><span class="term"><code class="constant">MT_ST_CAN_BSR</code> (Default:
                false)</span></dt>

                <dd>
                  <p>When read-ahead is used, the tape must
                  sometimes be spaced backward to the correct
                  position when the device is closed and the SCSI
                  command to space backward over records is used
                  for this purpose. Some older drives can't process
                  this command reliably and this option can be used
                  to instruct the driver not to use the command.
                  The end result is that, with read-ahead and
                  fixed-block mode, the tape may not be correctly
                  positioned within a file when the device is
                  closed. With 2.6 kernel, the default is true for
                  drives supporting SCSI-3.</p>
                </dd>

                <dt><span class="term"><code class="constant">MT_ST_NO_BLKLIMS</code> (Default:
                false)</span></dt>

                <dd>
                  <p>Some drives don't accept the <span class="emphasis"><em>READ BLOCK LIMITS</em></span> SCSI
                  command. If this is used, the driver does not use
                  the command. The drawback is that the driver
                  can't check before sending commands if the
                  selected block size is acceptable to the
                  drive.</p>
                </dd>

                <dt><span class="term"><code class="constant">MT_ST_CAN_PARTITIONS</code> (Default:
                false)</span></dt>

                <dd>
                  <p>This option enables support for several
                  partitions within a tape. The option applies to
                  all devices linked to a drive.</p>
                </dd>

                <dt><span class="term"><code class="constant">MT_ST_SCSI2LOGICAL</code> (Default:
                false)</span></dt>

                <dd>
                  <p>This option instructs the driver to use the
                  logical block addresses defined in the SCSI-2
                  standard when performing the seek and tell
                  operations (both with <code class="constant">MTSEEK</code> and <em class="parameter"><code>MTIOCPOS</code></em> commands
                  and when changing tape partition). Otherwise, the
                  device-specific addresses are used. It is highly
                  advisable to set this option if the drive
                  supports the logical addresses because they count
                  also filemarks. There are some drives that
                  support only the logical block addresses.</p>
                </dd>

                <dt><span class="term"><code class="constant">MT_ST_SYSV</code> (Default:
                false)</span></dt>

                <dd>
                  <p>When this option is enabled, the tape devices
                  use the SystemV semantics. Otherwise, the BSD
                  semantics are used. The most important difference
                  between the semantics is what happens when a
                  device used for reading is closed: in System V
                  semantics the tape is spaced forward past the
                  next filemark if this has not happened while
                  using the device. In BSD semantics the tape
                  position is not changed.</p>
                </dd>

                <dt><span class="term"><code class="constant">MT_NO_WAIT</code> (Default:
                false)</span></dt>

                <dd>
                  <p>Enables immediate mode (i.e., don't wait for
                  the command to finish) for some commands (e.g.,
                  rewind).</p>
                </dd>
              </dl>
            </div>

            <p>An example:</p>

            <div class="blockquote">
              <blockquote class="blockquote">
                <div class="informalexample">
                  <pre class="programlisting" xml:space="preserve">
struct mtop mt_cmd;
mt_cmd.mt_op = MTSETDRVBUFFER;
mt_cmd.mt_count = MT_ST_BOOLEANS |
        MT_ST_BUFFER_WRITES | MT_ST_ASYNC_WRITES;
ioctl(fd, MTIOCTOP, mt_cmd);
</pre>
                </div>
              </blockquote>
            </div>
          </blockquote>
        </div>

        <p>The default block size for a device can be set with
        <code class="constant">MT_ST_DEF_BLKSIZE</code> and the
        default density code can be set with <code class="constant">MT_ST_DEFDENSITY</code>. The values for the
        parameters are or'ed with the operation code.</p>

        <p>With kernels 2.1.x and later, the timeout values can be
        set with the subcommand <code class="constant">MT_ST_SET_TIMEOUT</code> ORed with the timeout
        in seconds. The long timeout (used for rewinds and other
        commands that may take a long time) can be set with
        <code class="constant">MT_ST_SET_LONG_TIMEOUT</code>. The
        kernel defaults are very long to make sure that a
        successful command is not timed out with any drive. Because
        of this, the driver may seem stuck even if it is only
        waiting for the timeout. These commands can be used to set
        more practical values for a specific drive. The timeouts
        set for one device apply for all devices linked to the same
        drive.</p>

        <p>Starting from kernels 2.4.19 and 2.5.43, the driver
        supports a status bit which indicates whether the drive
        requests cleaning. The method used by the drive to return
        cleaning information is set using the <code class="constant">MT_ST_SEL_CLN</code> subcommand. If the value is
        zero, the cleaning bit is always zero. If the value is one,
        the TapeAlert data defined in the SCSI-3 standard is used
        (not yet implemented). Values 2-17 are reserved. If the
        lowest eight bits are &gt;= 18, bits from the extended
        sense data are used. The bits 9-16 specify a mask to select
        the bits to look at and the bits 17-23 specify the bit
        pattern to look for. If the bit pattern is zero, one or
        more bits under the mask indicate the cleaning request. If
        the pattern is nonzero, the pattern must match the masked
        sense data byte.</p>
      </div>

      <div class="refsect2">
        <a id="st-4_sect5" name="st-4_sect5" shape="rect"> </a>

        <h3>MTIOCGET — get status</h3>

        <p>This request takes an argument of type <span class="emphasis"><em>(struct mtget *)</em></span>.</p>

        <div class="blockquote">
          <blockquote class="blockquote">
            <div class="structdef">
              <table style="border-collapse: collapse;">
                <colgroup span="1">
                  <col class="c1" span="1" />
                  <col class="c2" span="1" />
                  <col class="c3" span="1" />
                  <col class="c4" span="1" />
                  <col class="c5" span="1" />
                </colgroup>

                <tbody>
                  <tr>
                    <td style="" colspan="5" align="left" rowspan="1">
                      <div class="literallayout">
                        
                        /* structure for MTIOCGET \- mag tape get status command */
                      </div>
                    </td>
                  </tr>

                  <tr>
                    <td style="" colspan="5" rowspan="1"> </td>
                  </tr>

                  <tr>
                    <td class="structdefhdr" style="" align="left" rowspan="1" colspan="1">
                    struct</td>

                    <td class="structdefhdr" style="" colspan="4" align="left" rowspan="1"><span class="structname">mtget</span> {</td>
                  </tr>

                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>

                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">long</span></td>

                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>

                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>mt_type</code></em>;</td>

                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>

                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>

                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">long</span></td>

                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>

                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>mt_resid</code></em>;</td>

                    <td style="" align="left" rowspan="1" colspan="1">
                      <div class="literallayout">
                        
                        /* the following registers are device dependent */
                      </div>
                    </td>
                  </tr>

                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>

                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">long</span></td>

                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>

                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>mt_dsreg</code></em>;</td>

                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>

                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>

                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">long</span></td>

                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>

                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>mt_gstat</code></em>;</td>

                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>

                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>

                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">long</span></td>

                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>

                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>mt_erreg</code></em>;</td>

                    <td style="" align="left" rowspan="1" colspan="1">
                      <div class="literallayout">
                        
                        /* The next two fields are not always used */
                      </div>
                    </td>
                  </tr>

                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>

                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">daddr_t</span></td>

                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>

                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>mt_fileno</code></em>;</td>

                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>

                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>

                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">daddr_t</span></td>

                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>

                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>mt_blkno</code></em>;</td>

                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>

                  <tr>
                    <td class="structdefftr" style="" colspan="5" align="left" rowspan="1">};</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </blockquote>
        </div>

        <div class="variablelist">
          <dl class="variablelist">
            <dt><span class="term"><em class="parameter"><code>mt_type</code></em></span></dt>

            <dd>
              <p>The header file defines many values for <em class="parameter"><code>mt_type</code></em>, but the
              current driver reports only the generic types
              <code class="constant">MT_ISSCSI1</code> (Generic
              SCSI-1 tape) and <code class="constant">MT_ISSCSI2</code> (Generic SCSI-2
              tape).</p>
            </dd>

            <dt><span class="term"><em class="parameter"><code>mt_resid</code></em></span></dt>

            <dd>
              <p>contains the current tape partition number.</p>
            </dd>

            <dt><span class="term"><em class="parameter"><code>mt_dsreg</code></em></span></dt>

            <dd>
              <p>reports the drive's current settings for block
              size (in the low 24 bits) and density (in the high 8
              bits). These fields are defined by <code class="constant">MT_ST_BLKSIZE_SHIFT</code>, <code class="constant">MT_ST_BLKSIZE_MASK</code>, <code class="constant">MT_ST_DENSITY_SHIFT</code>, and
              <code class="constant">MT_ST_DENSITY_MASK</code>.</p>
            </dd>

            <dt><span class="term"><em class="parameter"><code>mt_gstat</code></em></span></dt>

            <dd>
              <p>reports generic (device independent) status
              information. The header file defines macros for
              testing these status bits:</p>

              <div class="blockquote">
                <blockquote class="blockquote">
                  <p><code class="constant">GMT_EOF</code>(<code class="literal">x</code>): The tape is positioned just
                  after a filemark (always false after an
                  <code class="constant">MTSEEK</code>
                  operation).</p>

                  <p><code class="constant">GMT_BOT</code>(<code class="literal">x</code>): The tape is positioned at
                  the beginning of the first file (always false
                  after an <code class="constant">MTSEEK</code>
                  operation).</p>

                  <p><code class="constant">GMT_EOT</code>(<code class="literal">x</code>): A tape operation has reached
                  the physical End Of Tape.</p>

                  <p><code class="constant">GMT_SM</code>(<code class="literal">x</code>): The tape is currently
                  positioned at a setmark (always false after an
                  <code class="constant">MTSEEK</code>
                  operation).</p>

                  <p><code class="constant">GMT_EOD</code>(<code class="literal">x</code>): The tape is positioned at
                  the end of recorded data.</p>

                  <p><code class="constant">GMT_WR_PROT</code>(<code class="literal">x</code>): The drive is
                  write-protected. For some drives this can also
                  mean that the drive does not support writing on
                  the current medium type.</p>

                  <p><code class="constant">GMT_ONLINE</code>(<code class="literal">x</code>): The last <a class="link" href="../htmlman2/open.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">open</span>(2)</span></a> found
                  the drive with a tape in place and ready for
                  operation.</p>

                  <p><code class="constant">GMT_D_6250</code>(<code class="literal">x</code>), <code class="constant">GMT_D_1600</code>(<code class="literal">x</code>), <code class="constant">GMT_D_800</code>(<code class="literal">x</code>): This <span class="quote">“<span class="quote">generic</span>”</span> status
                  information reports the current density setting
                  for 9-track ½" tape drives only.</p>

                  <p><code class="constant">GMT_DR_OPEN</code>(<code class="literal">x</code>): The drive does not have a
                  tape in place.</p>

                  <p><code class="constant">GMT_IM_REP_EN</code>(<code class="literal">x</code>): Immediate report mode. This
                  bit is set if there are no guarantees that the
                  data has been physically written to the tape when
                  the write call returns. It is set zero only when
                  the driver does not buffer data and the drive is
                  set not to buffer data.</p>

                  <p><code class="constant">GMT_CLN</code>(<code class="literal">x</code>): The drive has requested
                  cleaning. Implemented in kernels since 2.4.19 and
                  2.5.43.</p>
                </blockquote>
              </div>
            </dd>

            <dt><span class="term"><em class="parameter"><code>mt_erreg</code></em></span></dt>

            <dd>
              <p>The only field defined in <em class="parameter"><code>mt_erreg</code></em> is the
              recovered error count in the low 16 bits (as defined
              by <code class="constant">MT_ST_SOFTERR_SHIFT</code>
              and <code class="constant">MT_ST_SOFTERR_MASK</code>.
              Due to inconsistencies in the way drives report
              recovered errors, this count is often not maintained
              (most drives do not by default report soft errors but
              this can be changed with a SCSI MODE SELECT
              command).</p>
            </dd>

            <dt><span class="term"><em class="parameter"><code>mt_fileno</code></em></span></dt>

            <dd>
              <p>reports the current file number (zero-based). This
              value is set to −1 when the file number is
              unknown (e.g., after <code class="constant">MTBSS</code> or <code class="constant">MTSEEK</code>).</p>
            </dd>

            <dt><span class="term"><em class="parameter"><code>mt_blkno</code></em></span></dt>

            <dd>
              <p>reports the block number (zero-based) within the
              current file. This value is set to −1 when the
              block number is unknown (e.g., after <code class="constant">MTBSF</code>, <code class="constant">MTBSS</code>, or <code class="constant">MTSEEK</code>).</p>
            </dd>
          </dl>
        </div>
      </div>

      <div class="refsect2">
        <a id="st-4_sect6" name="st-4_sect6" shape="rect"> </a>

        <h3>MTIOCPOS — get tape position</h3>

        <p>This request takes an argument of type <span class="emphasis"><em>(struct mtpos *)</em></span> and reports the
        drive's notion of the current tape block number, which is
        not the same as <em class="parameter"><code>mt_blkno</code></em> returned by
        <em class="parameter"><code>MTIOCGET</code></em>. This
        drive must be a SCSI-2 drive that supports the <span class="emphasis"><em>READ POSITION</em></span> command
        (device-specific address) or a Tandberg-compatible SCSI-1
        drive (Tandberg, Archive Viper, Wangtek, ... ).</p>

        <div class="blockquote">
          <blockquote class="blockquote">
            <div class="structdef">
              <table style="border-collapse: collapse;">
                <colgroup span="1">
                  <col class="c1" span="1" />
                  <col class="c2" span="1" />
                  <col class="c3" span="1" />
                  <col class="c4" span="1" />
                  <col class="c5" span="1" />
                </colgroup>

                <tbody>
                  <tr>
                    <td style="" colspan="5" align="left" rowspan="1">
                      <div class="literallayout">
                        
                        /* structure for MTIOCPOS \- mag tape get position command */
                      </div>
                    </td>
                  </tr>

                  <tr>
                    <td style="" colspan="5" rowspan="1"> </td>
                  </tr>

                  <tr>
                    <td class="structdefhdr" style="" align="left" rowspan="1" colspan="1">
                    struct</td>

                    <td class="structdefhdr" style="" colspan="4" align="left" rowspan="1"><span class="structname">mtpos</span> {</td>
                  </tr>

                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>

                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">long</span></td>

                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>

                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>mt_blkno</code></em>;</td>

                    <td style="" align="left" rowspan="1" colspan="1">
                      <div class="literallayout">
                        
                        /* current block number */
                      </div>
                    </td>
                  </tr>

                  <tr>
                    <td class="structdefftr" style="" colspan="5" align="left" rowspan="1">};</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </blockquote>
        </div>
      </div>
    </div>

    <div class="refsect1">
      <a id="st-4_sect7" name="st-4_sect7" shape="rect"> </a>

      <h2>RETURN VALUE</h2>

      <div class="variablelist">
        <dl class="variablelist">
          <dt><span class="term"><span class="errorname">EACCES</span></span></dt>

          <dd>
            <p>An attempt was made to write or erase a
            write-protected tape. (This error is not detected
            during <a class="link" href="../htmlman2/open.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">open</span>(2)</span></a>.)</p>
          </dd>

          <dt><span class="term"><span class="errorname">EBUSY</span></span></dt>

          <dd>
            <p>The device is already in use or the driver was
            unable to allocate a buffer.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EFAULT</span></span></dt>

          <dd>
            <p>The command parameters point to memory not belonging
            to the calling process.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EINVAL</span></span></dt>

          <dd>
            <p>An <a class="link" href="../htmlman2/ioctl.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">ioctl</span>(2)</span></a> had an
            invalid argument, or a requested block size was
            invalid.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EIO</span></span></dt>

          <dd>
            <p>The requested operation could not be completed.</p>
          </dd>

          <dt><span class="term"><span class="errorname">ENOMEM</span></span></dt>

          <dd>
            <p>The byte count in <a class="link" href="../htmlman2/read.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">read</span>(2)</span></a> is smaller
            than the next physical block on the tape. (Before
            2.2.18 and 2.4.0-test6 the extra bytes have been
            silently ignored.)</p>
          </dd>

          <dt><span class="term"><span class="errorname">ENOSPC</span></span></dt>

          <dd>
            <p>A write operation could not be completed because the
            tape reached end-of-medium.</p>
          </dd>

          <dt><span class="term"><span class="errorname">ENOSYS</span></span></dt>

          <dd>
            <p>Unknown <a class="link" href="../htmlman2/ioctl.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">ioctl</span>(2)</span></a>.</p>
          </dd>

          <dt><span class="term"><span class="errorname">ENXIO</span></span></dt>

          <dd>
            <p>During opening, the tape device does not exist.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EOVERFLOW</span></span></dt>

          <dd>
            <p>An attempt was made to read or write a
            variable-length block that is larger than the driver's
            internal buffer.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EROFS</span></span></dt>

          <dd>
            <p>Open is attempted with <code class="constant">O_WRONLY</code> or <code class="constant">O_RDWR</code> when the tape in the drive is
            write-protected.</p>
          </dd>
        </dl>
      </div>
    </div>

    <div class="refsect1">
      <a id="st-4_sect8" name="st-4_sect8" shape="rect"> </a>

      <h2>FILES</h2>

      <div class="variablelist">
        <dl class="variablelist">
          <dt><span class="term"><code class="filename">/dev/st*</code></span></dt>

          <dd>
            <p>the auto-rewind SCSI tape devices</p>
          </dd>

          <dt><span class="term"><code class="filename">/dev/nst*</code></span></dt>

          <dd>
            <p>the nonrewind SCSI tape devices</p>
          </dd>
        </dl>
      </div>
    </div>

    <div class="refsect1">
      <a id="st-4_sect9" name="st-4_sect9" shape="rect"> </a>

      <h2>NOTES</h2>

      <div class="orderedlist">
        <ol class="orderedlist" type="1">
          <li class="listitem">
            <p>When exchanging data between systems, both systems
            have to agree on the physical tape block size. The
            parameters of a drive after startup are often not the
            ones most operating systems use with these devices.
            Most systems use drives in variable-block mode if the
            drive supports that mode. This applies to most modern
            drives, including DATs, 8mm helical scan drives, DLTs,
            etc. It may be advisable to use these drives in
            variable-block mode also in Linux (i.e., use
            <code class="constant">MTSETBLK</code> or <code class="constant">MTSETDEFBLK</code> at system startup to set
            the mode), at least when exchanging data with a foreign
            system. The drawback of this is that a fairly large
            tape block size has to be used to get acceptable data
            transfer rates on the SCSI bus.</p>
          </li>

          <li class="listitem">
            <p>Many programs (e.g., <span class="citerefentry"><span class="refentrytitle">tar</span>(1)</span>) allow the user to
            specify the blocking factor on the command line. Note
            that this determines the physical block size on tape
            only in variable-block mode.</p>
          </li>

          <li class="listitem">
            <p>In order to use SCSI tape drives, the basic SCSI
            driver, a SCSI-adapter driver and the SCSI tape driver
            must be either configured into the kernel or loaded as
            modules. If the SCSI-tape driver is not present, the
            drive is recognized but the tape support described in
            this page is not available.</p>
          </li>

          <li class="listitem">
            <p>The driver writes error messages to the console/log.
            The SENSE codes written into some messages are
            automatically translated to text if verbose SCSI
            messages are enabled in kernel configuration.</p>
          </li>

          <li class="listitem">
            <p>The driver's internal buffering allows good
            throughput in fixed-block mode also with small
            <a class="link" href="../htmlman2/read.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">read</span>(2)</span></a> and <a class="link" href="../htmlman2/write.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">write</span>(2)</span></a> byte counts.
            With direct transfers this is not possible and may
            cause a surprise when moving to the 2.6 kernel. The
            solution is to tell the software to use larger
            transfers (often telling it to use larger blocks). If
            this is not possible, direct transfers can be
            disabled.</p>
          </li>
        </ol>
      </div>
    </div>

    <div class="refsect1">
      <a id="st-4_sect10" name="st-4_sect10" shape="rect"> </a>

      <h2>SEE ALSO</h2>

      <p><span class="citerefentry"><span class="refentrytitle">mt</span>(1)</span></p>

      <p>The file <em class="replaceable"><code>drivers/scsi/README.st</code></em> or
      <code class="filename">Documentation/scsi/st.txt</code>
      (kernel &gt;= 2.6) in the Linux kernel source tree contains
      the most recent information about the driver and its
      configuration possibilities</p>
    </div>

    <div class="colophon">
      <a id="st-4_sect11" name="st-4_sect11" shape="rect"> </a>

      <h2>COLOPHON</h2>

      <p>This page is part of release 4.00 of the Linux <em class="replaceable"><code>man-pages</code></em> project. A
      description of the project, information about reporting bugs,
      and the latest version of this page, can be found at
      http://www.kernel.org/doc/man−pages/.</p>

      <div class="license">
        <table style="border-collapse: collapse;">
          <colgroup span="1">
            <col span="1" />
          </colgroup>

          <tbody>
            <tr>
              <td style="" rowspan="1" colspan="1">
                <div class="literallayout">
                  <br />
                    Copyright 1995 Robert K. Nichols (Robert.K.Nichols<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>att.com)<br />

                  Copyright 1999-2005 Kai Mäkisara (Kai.Makisara<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>kolumbus.fi)<br />

                  <br />
                  %%%LICENSE_START(VERBATIM)<br />
                  Permission is granted to make and distribute verbatim copies of this<br />

                  manual provided the copyright notice and this permission notice are<br />

                  preserved on all copies.<br />
                  <br />
                  Permission is granted to copy and distribute modified versions of this<br />

                  manual under the conditions for verbatim copying, provided that the<br />

                  entire resulting derived work is distributed under the terms of a<br />

                  permission notice identical to this one.<br />

                  <br />
                  Since the Linux kernel and libraries are constantly changing, this<br />

                  manual page may be incorrect or out-of-date.  The author(s) assume no<br />

                  responsibility for errors or omissions, or for damages resulting from<br />

                  the use of the information contained herein.  The author(s) may not<br />

                  have taken the same level of care in the production of this manual,<br />

                  which is licensed free of charge, as they might when working<br />

                  professionally.<br />
                  <br />
                  Formatted or processed versions of this manual, if unaccompanied by<br />

                  the source, must acknowledge the copyright and authors of this work.<br />

                  %%%LICENSE_END<br />
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</body>
</html>
